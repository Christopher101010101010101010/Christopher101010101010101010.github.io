<html>
<style>
  .headerDiv{
    display: flex;
    background-color: #ee0e0e;
    align-items: center;
    justify-content: center;
    padding: 10px;
    height: 90px;
    width: 100%;
  }
  .bodyDiv{
    display: flex;
    background-color: #e8e8e8;
    
    text-align: left;
    padding: 20px;
    height: 100%;
    width: 100%;
  }
  .codeDiv{
    justify-content: center;
    display: flex;
    background-color: #e8e8e8;
    height: 100%;
    width: 100%;
  }
  .origDiv{
    justify-content: left;
    display: flex;
    background-color: #e8e8e8;
    height: 100%;
    width: 50%;
  }
</style>

<body>
  <div class= "headerDiv">
    <H2>Software Design & Engineering Artifact (Artifact 1)&nbsp;&nbsp;</H2>
  </div>
  <div class= "bodyDiv">
    <H2>Artifact 1 repository files&emsp;
    <a href="https://github.com/Christopher101010101010101010/Christopher101010101010101010.github.io/blob/main/gpiointerruptARTIFACT1UPDATED.c" >updated version </a>
     &ensp;|&ensp; 
    <a href="https://github.com/Christopher101010101010101010/Christopher101010101010101010.github.io/blob/main/gpiointerruptARTIFACT1ORIGINAL.c" >original version </a></H2>
    <br><br>
        
  </div>

  <div class= "codeDiv">
    <div class= "origDiv">
      <H3><br><br>Original code<br><br></H3>
      <p><br><br>/*<br>
         *  ======== gpiointerrupt.c ========<br>
         */<br>
        #include <stdint.h><br>
        #include <stddef.h><br>
        <br>
        /* Driver Header files */<br>
        #include <ti/drivers/GPIO.h><br>
        <br>
        /* Driver configuration */<br>
        #include "ti_drivers_config.h"<br>
        <br>
        <br>
        /* Project header files */<br>
        #include <ti/drivers/I2C.h><br>
        #include <ti/drivers/UART2.h><br>
        #include <ti/drivers/Timer.h><br>
        #include <stdio.h><br>
        <br>
        // UART Global Variables<br>
        char output[64];<br>
        int bytesToSend;<br>
        <br>
        // Driver Handles - Global variables<br>
        UART2_Handle uart;<br>
        <br>
        #define DISPLAY(x) UART2_write(uart, &output, x, 0);<br>
        <br>
        void initUART(void)<br>
        {<br>
            UART2_Params uartParams;<br>
        <br>
            // Configure the driver<br>
            UART2_Params_init(&uartParams);<br>
            uartParams.writeMode = UART2_Mode_CALLBACK;<br>
            uartParams.readMode = UART2_Mode_CALLBACK;<br>
        <br>
            uartParams.baudRate = 115200;<br>
        <br>
            // Open the driver<br>
            uart = UART2_open(CONFIG_UART2_0, &uartParams);<br>
        <br>
            if (uart == NULL) {<br>
                /* UART_open() failed */<br>
                while (1);<br>
            }<br>
        }<br>
        <br>
        // Driver Handles - Global variables<br>
        Timer_Handle timer0;<br>
        int periodCondition = 0;<br>
        <br>
        volatile unsigned char TimerFlag = 0;<br>
        void timerCallback(Timer_Handle myHandle, int_fast16_t status)<br>
        {<br>
            if(periodCondition < 10)<br>
                periodCondition++;<br>
        <br>
            else<br>
                periodCondition = 0;<br>
        }<br>
        <br>
        void initTimer(void)<br>
        {<br>
            Timer_Params params;<br>
        <br>
            // Init the driver<br>
            Timer_init();<br>
        <br>
            // Configure the driver<br>
            Timer_Params_init(&params);<br>
            params.period = 100000;<br>
            params.periodUnits = Timer_PERIOD_US;<br>
            params.timerMode = Timer_CONTINUOUS_CALLBACK;<br>
            params.timerCallback = timerCallback;<br>
        <br>
            // Open the driver<br>
            timer0 = Timer_open(CONFIG_TIMER_0, &params);<br>
            if (timer0 == NULL) {<br>
                /* Failed to initialized timer */<br>
                while (1) {}<br>
            }<br>
            if (Timer_start(timer0) == Timer_STATUS_ERROR) {<br>
                /* Failed to start timer */<br>
                while (1) {}<br>
            }<br>
        }<br>
        <br>
        // I2C Global Variables<br>
        static const struct {<br>
            uint8_t address;<br>
            uint8_t resultReg;<br>
            char *id;<br>
        } sensors[3] = {<br>
                        { 0x48, 0x0000, "11X" },<br>
                        { 0x49, 0x0000, "116" },<br>
                        { 0x41, 0x0001, "006" }<br>
        };<br>
        <br>
        uint8_t txBuffer[1];<br>
        uint8_t rxBuffer[2];<br>
        I2C_Transaction i2cTransaction;<br>
        <br>
        // Driver Handles - Global variables<br>
        I2C_Handle i2c;<br>
        
        // Make sure you call initUART() before calling this function.<br>
        void initI2C(void)<br>
        {<br>
            int8_t i, found;<br>
            I2C_Params i2cParams;<br>
            DISPLAY( snprintf(output, 64, "Initializing I2C Driver - "));<br>
        <br>
            // Init the driver<br>
            I2C_init();<br>
        <br>
            // Configure the driver<br>
            I2C_Params_init(&i2cParams);<br>
            i2cParams.bitRate = I2C_400kHz;<br>
        <br>
            // Open the driver<br>
            i2c = I2C_open(CONFIG_I2C_0, &i2cParams);<br>
            if (i2c == NULL)<br>
            {<br>
                DISPLAY( snprintf(output, 64, "Failed\n\r"));<br>
                while (1);<br>
            }<br>
        <br>
            DISPLAY( snprintf(output, 32, "Passed\n\r"));<br>
        <br>
            // Boards were shipped with different sensors.<br>
            // Welcome to the world of embedded systems.<br>
            // Try to determine which sensor we have.<br>
            // Scan through the possible sensor addresses<br>
        <br>
            /* Common I2C transaction setup */<br>
            i2cTransaction.writeBuf = txBuffer;<br>
            i2cTransaction.writeCount = 1;<br>
            i2cTransaction.readBuf = rxBuffer;<br>
            i2cTransaction.readCount = 0;<br>
        <br>
            found = false;<br>
            for (i=0; i<3; ++i)<br>
            {<br>
                i2cTransaction.targetAddress = sensors[i].address;<br>
                txBuffer[0] = sensors[i].resultReg;<br>
                DISPLAY( snprintf(output, 64, "Is this %s? ", sensors[i].id));<br>
                if (I2C_transfer(i2c, &i2cTransaction))<br>
                {<br>
                    DISPLAY( snprintf(output, 64, "Found\n\r"));<br>
                    found = true;<br>
                    break;<br>
                }<br>
                DISPLAY( snprintf(output, 64, "No\n\r"));<br>
            }<br>
        <br>
            if(found)<br>
            {<br>
                DISPLAY( snprintf(output, 64, "Detected TMP%s I2C address: %x\n\r", sensors[i].id, i2cTransaction.targetAddress));<br>
            }<br>
            else<br>
            {<br>
                DISPLAY( snprintf(output, 64, "Temperature sensor not found, contact professor\n\r"));<br>
            }<br>
        }<br>
        <br>
        int16_t readTemp(void)<br>
        {<br>
            int16_t temperature = 0;<br>
            i2cTransaction.readCount = 2;<br>
            if (I2C_transfer(i2c, &i2cTransaction))<br>
            {<br>
                /*<br>
                 * Extract degrees C from the received data;<br>
                 * see TMP sensor datasheet<br>
                 */<br>
                temperature = (rxBuffer[0] << 8) | (rxBuffer[1]);<br>
                temperature *= 0.0078125;<br>
                /*<br>
                 * If the MSB is set '1', then we have a 2's complement<br>
                 * negative value which needs to be sign extended<br>
                 */<br>
                if (rxBuffer[0] & 0x80)<br>
                {<br>
                    temperature |= 0xF000;<br>
                }<br>
            }<br>
            else<br>
            {<br>
                DISPLAY( snprintf(output, 64, "Error reading temperature sensor (%d)\n\r", i2cTransaction.status));<br>
                DISPLAY( snprintf(output, 64, "Please power cycle your board by unplugging/plugging back in.\n\r"));<br>
            }<br>
            return temperature;<br>
        }<br>
        <br>
        //global temperature variables<br>
        uint16_t setPoint = 0;<br>
        uint16_t roomTemp = 0;<br>
        <br>
        /*<br>
         *  ======== gpioButtonFxn0 ========<br>
         *  Callback function for the GPIO interrupt on CONFIG_GPIO_BUTTON_0.<br>
         *<br>
         *  Note: GPIO interrupts are cleared prior to invoking callbacks.<br>
         */<br>
        void gpioButtonFxn0(uint_least8_t index)<br>
        {<br>
            //increase set point temperature value by 1 degree<br>
            setPoint++;<br>
            usleep(200000);<br>
        }<br>
        <br>
        /*<br>
         *  ======== gpioButtonFxn1 ========<br>
         *  Callback function for the GPIO interrupt on CONFIG_GPIO_BUTTON_1.<br>
         *  This may not be used for all boards.<br>
         *<br>
         *  Note: GPIO interrupts are cleared prior to invoking callbacks.<br>
         */<br>
        void gpioButtonFxn1(uint_least8_t index)<br>
        {<br>
            //increase set point temperature value by 1 degree<br>
            setPoint--;<br>
            usleep(200000);<br>
        }<br>
        <br>
        /*<br>
         *  ======== mainThread ========<br>
         */<br>
        void *mainThread(void *arg0)<br>
        {<br>
            /* Call driver init functions */<br>
            GPIO_init();<br>
            initUART();<br>
            initTimer();<br>
            initI2C();<br>
        <br>
            /* Configure the LED and button pins */<br>
            GPIO_setConfig(CONFIG_GPIO_LED_0, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>
        <br>
            GPIO_setConfig(CONFIG_GPIO_BUTTON_0, GPIO_CFG_IN_PU | GPIO_CFG_IN_INT_FALLING);<br>
            GPIO_setConfig(CONFIG_GPIO_BUTTON_1, GPIO_CFG_IN_PU | GPIO_CFG_IN_INT_FALLING);<br>
        <br>
            /* Turn on user LED */<br>
            GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
        <br>
            /* Install Button callback */<br>
            GPIO_setCallback(CONFIG_GPIO_BUTTON_0, gpioButtonFxn0);<br>
            GPIO_setCallback(CONFIG_GPIO_BUTTON_1, gpioButtonFxn1);<br>
        <br>
            /* Enable interrupts */<br>
            GPIO_enableInt(CONFIG_GPIO_BUTTON_0);<br>
            GPIO_enableInt(CONFIG_GPIO_BUTTON_1);<br>
        <br>
            // initialize room-temp to current temperature read by device.<br>
            // initialize set point to the room temperature<br>
            roomTemp = readTemp();<br>
            setPoint = roomTemp;<br>
            uint32_t serverDisplayTicks = 10000000;<br>
            uint16_t totalTime = 0;<br>
            unsigned short heatStatus = 0;<br>
        <br>
            //Testin1<br>
            DISPLAY( snprintf(output, 64, "<%02d,%02d,%d,%04d>\n\r", roomTemp, setPoint, heatStatus, totalTime));<br>
        <br>
            while(1){<br>
                switch(periodCondition){<br>
        <br>
                    case 0:                                                                     // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
                        break;<br>
        <br>
                    case 2:                                                                    // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
                        break;<br>
        <br>
                    case 4:                                                                     // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
                        break;<br>
        <br>
                    case 5:                                                                     // every 500 ms update roomTemp to current room temperature measured<br>
                        roomTemp = readTemp();<br>
                                   if(!(roomTemp > -1 && roomTemp < 100)){                      // if room temperature reading is out-of-bounds set room-temp to 0<br>
                                       //error code                                             // and turn off heatStatus/LED<br>
                                       roomTemp = 0;<br>
                                       GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                       heatStatus = 0;<br>
                                   }<br>
                        break;<br>
        <br>
                    case 6:                                                                     // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
                        break;<br>
        <br>
                    case 8:                                                                     // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
                        break;<br>
        <br>
                    case 10:                                                                    // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
        <br>
                        totalTime = Timer_getCount(timer0) / serverDisplayTicks;                // every 1 sec update server with thermostats current data<br>
                        DISPLAY(snprintf(output, 64, "<%02d,%02d,%d,%04d>\n\r", roomTemp, setPoint, heatStatus, totalTime));<br>
                        break;<br>
        <br>
                    default:<br>
                        break;<br>
        <br>
                }<br>
        <br>
            }<br>
        <br>
            return;<br>
        }<br>
    </p></div>

    </div>
</body>
</html>
