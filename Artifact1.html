<html>
<style>
 .headerDiv{
    display: flex;
    background-color: #fdff00;
    align-items: center;
    justify-content: center;
    padding: 20px;
    height: 90px;
    width: 100%;
  }
  .dividerDiv{
    background-color: #4682b4;
    height: 25px;
    padding: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
  }
  .bodyDiv{
    display: flex;
    background-color: #CDFCFE;
    align-items: top;
    justify-content: left;
    padding: 20px;
    height: 15000px;
    width: 100%;
  }
  .linksDiv{
    display: flex;
    background-color: #CDFCFE;
    position: absolute;
    top: 250px;
    z-index: 3;
    text-align: left;
    padding: 20px;
    height: 100px;
    width: 1000px;
  }
  .narrativeDiv{
    text-align: left;
    align-items: normal;
    position: absolute;
    top: 375;
    z-index: 2;
    display: flex;
    background-color: #CDFCFE;
    padding: 20px;
    height: 1000px;
    width: 1000px;
  
    font-size: 18px;
    line-height: 1.750;
  }
 .codeDiv{
    text-align: left;
    align-items: normal;
    position: absolute;
    top: 1600;
    z-index: 3;
    display: flex;
    background-color: #CDFCFE;
    padding: 40px;
    height: 13000px;
    width: 100%;
  
    font-size: 18px;
    line-height: 1.750;

 }
</style>

<body>
  <div class= "headerDiv">
    <H2>Software Design & Engineering Artifact (Artifact 1)&nbsp;&nbsp;</H2>
  </div>
  <div class="dividerDiv">
    <H2><a href= "index.html"> ePortfolio Home </a> 
    &emsp;&emsp;&emsp;&emsp; | &emsp;&emsp;&emsp;&emsp;
    <a href= "Artifact2.html"> Artifact 2 </a>
    &emsp;&emsp;&emsp;&emsp; | &emsp;&emsp;&emsp;&emsp;
    <a href= "Artifact3.html"> Artifact 3 </a>
    </H2>
  </div>
  
  <div class= "bodyDiv">

    <div class="linksDiv">
    <H2>Artifact 1 repository files&emsp;
    <a href="https://github.com/Christopher101010101010101010/Christopher101010101010101010.github.io/blob/main/gpiointerruptARTIFACT1UPDATED.c" >updated version </a>
     &ensp;|&ensp; 
    <a href="https://github.com/Christopher101010101010101010/Christopher101010101010101010.github.io/blob/main/gpiointerruptARTIFACT1ORIGINAL.c" >original version </a></H2>
    <br><br>
    </div>

    <div class="narrativeDiv">
        <p>
          &emsp;In this update for Software Design and Engineering of an artifact, I have improved the<br>
          final project of the Emerging System Architecture course. This artifact is a heating only<br>
          thermostat program that utilizes the two-button interface and thermopile sensor of a Texas<br>
          Instruments CC3220S; this software package was originally developed in June of 2024 as the<br>
          culmination of my learning for embedded systems development. Through the integration of the<br>
          CC3220S board’s left button and right button the original project allowed a user to increase<br>
          and decrease a preferred temperature that would activate or deactivate a red LED on the board<br>
          based upon a comparison with the temperature reading from the board’s integrated thermopile.<br>
          The final project of Emerging System Architecture originally included exclusively heating thermostat<br>
          components though it has been improved with a cooling mode algorithm in this update for Enhancement<br>
          One: Software Design and Engineering of the Computer Science Capstone.<br><br>
        
          &emsp;The inclusion of this Embedded Systems artifact to my ePortfolio shares my competency in engineering<br>
          for restrictive environments. This artifact showcases an appreciation for device activity timing, and<br>
          embedded system development practices; in the updated version of this software, the code has been<br>
          modalized for additional efficiency, new if-else branches for cooling mode behaviors, and an innovative<br>
          solution to the CC3220S board’s two-button interface in which the board will cycle to the next system<br>
          mode when both buttons are pressed simultaneously that will effectively allow the software to behave<br>
          as though there is a three-button interface. As anticipated, the Enhancement One: Software Design and<br>
          Engineering artifact improvements have satisfied course outcomes #3, and #4 as the process of updating<br>
          this Embedded Systems software focused upon the design and implementation of the AC/cooling mode feature<br>
          without consideration for presenting to peers, coordinating updates with peers, or improving upon the<br>
          security of the existing software. This software package displays competency in restrictive hardware<br>
          environments making this program a perfect addition to my ePortfolio as an example of my Software Design<br>
          and Engineering skillset.<br><br>

          &emsp;Throughout the process of integrating the cooling mode update to the Emerging System Architecture<br>
          artifact, I have been reminded of the importance of programming best practices. When initially developing<br>
          this program in June 2024, I recall, learning how the CC3220S board’s thermopile stores temperature readings<br>
          at three potential memory addresses along with how to retrieve and convert this data into degrees Fahrenheit.<br>
          During the implementation of the update code to integrate a cooling mode, I learned that the simultaneous<br>
          activation of the left and right board buttons could be coded as a separate trigger allowing for the system mode<br>
          to be altered without compromising the individual functionality of the left button or right button that<br>
          increase/decrease the set point temperature. Further, I sought to apply greater modulization and commenting of<br>
          the code in this updated version of the thermostat program to increase efficiency, readability, and scalability.<br>
          Development best practices took a core role in my designs for the cooling mode update to the Embedded Systems<br>
          software artifact.
        </p>
    </div>

   <div class="codeDiv">
    <div>
      <p><H3><br><br>Original code<br><br></H3>
      
        //global temperature variables<br>
        uint16_t setPoint = 0;<br>
        uint16_t roomTemp = 0;<br>
        <br>
        /*<br>
         *  ======== gpioButtonFxn0 ========<br>
         *  Callback function for the GPIO interrupt on CONFIG_GPIO_BUTTON_0.<br>
         *<br>
         *  Note: GPIO interrupts are cleared prior to invoking callbacks.<br>
         */<br>
        void gpioButtonFxn0(uint_least8_t index)<br>
        {<br>
            //increase set point temperature value by 1 degree<br>
            setPoint++;<br>
            usleep(200000);<br>
        }<br>
        <br>
        /*<br>
         *  ======== gpioButtonFxn1 ========<br>
         *  Callback function for the GPIO interrupt on CONFIG_GPIO_BUTTON_1.<br>
         *  This may not be used for all boards.<br>
         *<br>
         *  Note: GPIO interrupts are cleared prior to invoking callbacks.<br>
         */<br>
        void gpioButtonFxn1(uint_least8_t index)<br>
        {<br>
            //increase set point temperature value by 1 degree<br>
            setPoint--;<br>
            usleep(200000);<br>
        }<br>
        <br>
        /*<br>
         *  ======== mainThread ========<br>
         */<br>
        void *mainThread(void *arg0)<br>
        {<br>
            /* Call driver init functions */<br>
            GPIO_init();<br>
            initUART();<br>
            initTimer();<br>
            initI2C();<br>
        <br>
            /* Configure the LED and button pins */<br>
            GPIO_setConfig(CONFIG_GPIO_LED_0, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>
        <br>
            GPIO_setConfig(CONFIG_GPIO_BUTTON_0, GPIO_CFG_IN_PU | GPIO_CFG_IN_INT_FALLING);<br>
            GPIO_setConfig(CONFIG_GPIO_BUTTON_1, GPIO_CFG_IN_PU | GPIO_CFG_IN_INT_FALLING);<br>
        <br>
            /* Turn on user LED */<br>
            GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
        <br>
            /* Install Button callback */<br>
            GPIO_setCallback(CONFIG_GPIO_BUTTON_0, gpioButtonFxn0);<br>
            GPIO_setCallback(CONFIG_GPIO_BUTTON_1, gpioButtonFxn1);<br>
        <br>
            /* Enable interrupts */<br>
            GPIO_enableInt(CONFIG_GPIO_BUTTON_0);<br>
            GPIO_enableInt(CONFIG_GPIO_BUTTON_1);<br>
        <br>
            // initialize room-temp to current temperature read by device.<br>
            // initialize set point to the room temperature<br>
            roomTemp = readTemp();<br>
            setPoint = roomTemp;<br>
            uint32_t serverDisplayTicks = 10000000;<br>
            uint16_t totalTime = 0;<br>
            unsigned short heatStatus = 0;<br>
        <br>
            //Testin1<br>
            DISPLAY( snprintf(output, 64, "<%02d,%02d,%d,%04d>\n\r", roomTemp, setPoint, heatStatus, totalTime));<br>
        <br>
            while(1){<br>
                switch(periodCondition){<br>
        <br>
                    case 0:                                                                     // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
                        break;<br>
        <br>
                    case 2:                                                                    // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
                        break;<br>
        <br>
                    case 4:                                                                     // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
                        break;<br>
        <br>
                    case 5:                                                                     // every 500 ms update roomTemp to current room temperature measured<br>
                        roomTemp = readTemp();<br>
                                   if(!(roomTemp > -1 && roomTemp < 100)){                      // if room temperature reading is out-of-bounds set room-temp to 0<br>
                                       //error code                                             // and turn off heatStatus/LED<br>
                                       roomTemp = 0;<br>
                                       GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                       heatStatus = 0;<br>
                                   }<br>
                        break;<br>
        <br>
                    case 6:                                                                     // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
                        break;<br>
        <br>
                    case 8:                                                                     // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
                        break;<br>
        <br>
                    case 10:                                                                    // every 200 ms update the LED and heat mode status to ON/OFF<br>
                        if(roomTemp  < setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                                        heatStatus = 1;<br>
                                    }<br>
                                    else if(roomTemp >= setPoint){<br>
                                        GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                                        heatStatus = 0;<br>
                                    }<br>
        <br>
                        totalTime = Timer_getCount(timer0) / serverDisplayTicks;                // every 1 sec update server with thermostats current data<br>
                        DISPLAY(snprintf(output, 64, "<%02d,%02d,%d,%04d>\n\r", roomTemp, setPoint, heatStatus, totalTime));<br>
                        break;<br>
        <br>
                    default:<br>
                        break;<br>
        <br>
                }<br>
        <br>
            }<br>
        <br>
            return;<br>
        }<br>
    </p></div>

    <div>
         <p><H3><br><br>Updated code<br><br></H3>
          //global temperature variables<br>
          <br>
          uint16_t setPoint = 0;              //TI CC3220S board's button interface controlled variable to set user defined temperature preference<br>
          uint16_t roomTemp = 0;              //TI CC3220S board's thermopile(temperature sensor) defined variable for degree F reading local to device<br>
          uint16_t systemMode = 0;            //0, off. 1, heating. 2, cooling.<br>
          uint16_t activationStatus = 0;      //0, off. 1, on<br>
          <br>
          uint16_t button0Activation = 0;     //0, inactive. 1, active.<br>
          uint16_t button1Activation = 0;     //0, inactive. 1, active.<br>
          <br>
          /*<br>
           *  ======== gpioButtonFxn0 ========<br>
           *  Callback function for the GPIO interrupt on CONFIG_GPIO_BUTTON_0.<br>
           *<br>
           *  Note: GPIO interrupts are cleared prior to invoking callbacks.<br>
           */<br>
          void gpioButtonFxn0(uint_least8_t index)<br>
          {<br>
              //increase set point temperature value by 1 degree<br>
              setPoint++;<br>
              button0Activation = 1;              // set button activation status to on<br>
              usleep(200000);                     // only check for altered button state every 200 ms<br>
          <br>
          }<br>
          <br>
          /*<br>
           *  ======== gpioButtonFxn1 ========<br>
           *  Callback function for the GPIO interrupt on CONFIG_GPIO_BUTTON_1.<br>
           *  This may not be used for all boards.<br>
           *<br>
           *  Note: GPIO interrupts are cleared prior to invoking callbacks.<br>
           */<br>
          void gpioButtonFxn1(uint_least8_t index)<br>
          {<br>
              //increase set point temperature value by 1 degree<br>
              setPoint--;<br>
              button1Activation = 1;              // set button activation status to on<br>
              usleep(200000);                     // only check for altered button state every 200 ms<br>
          <br>
          }<br>
          <br>
          void buttonStatusCh(){<br>
              //check for both buttons being active<br>
              //if both buttons are active cycle to the next system mode setting<br>
              //0, off. 1, heating mode. 2, cooling mode.<br>
              if(button0Activation == 1 && button1Activation == 1){<br>
                  if(systemMode < 2 && systemMode > -1){<br>
                      systemMode++;<br>
                  }<br>
                  else if(systemMode == 2){<br>
                      systemMode = 0;<br>
                  }<br>
                  else{<br>
                      DISPLAY( snprintf(output, 150, "Error: systemMode setting out of bounds\nDEACTIVATING SYSTEM."));<br>
                      systemMode = 0;<br>
                  }<br>
              }<br>
          }<br>
          <br>
          void checkTempStatus(){<br>
              if(roomTemp  < setPoint && systemMode == 1){                            //if room temp is less than set point and the system is in heating mode then activate system<br>
                   GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
                   activationStatus = 1;<br>
              }<br>
              else if(roomTemp > setPoint && systemMode == 2){                        //else-if room temp is greater than set point and the system is in cooling mode then activate system<br>
                  GPIO_write(CONFIG_GPIO_LED_1, CONFIG_GPIO_LED_ON);<br>
                  activationStatus = 1;<br>
              }<br>
              else if(roomTemp >= setPoint && systemMode == 1){                       //else-if room temp is greater than or equal to set point and system is in heating mode then deactivate system<br>
                   GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                   activationStatus = 0;<br>
              }<br>
              else if(roomTemp <= setPoint && systemMode == 2){                       //else-if room temp is less than or equal to set point and system is in cooling mode then deactivate system<br>
                  GPIO_write(CONFIG_GPIO_LED_1, CONFIG_GPIO_LED_OFF);<br>
                  activationStatus = 0;<br>
              }<br>
          }<br>
          <br>
          void buttonReset(){                                                         //Reset button activation status to avoid trigger unwanted system mode cycling<br>
              button0Activation = 0;<br>
              button1Activation = 0;<br>
          }<br>
          <br>
          <br>
          /*<br>
           *  ======== mainThread ========<br>
           */<br>
          void *mainThread(void *arg0)<br>
          {<br>
              /* Call driver init functions */<br>
              GPIO_init();<br>
              initUART();<br>
              initTimer();<br>
              initI2C();<br>
          <br>
              /* Configure the LED and button pins */<br>
              GPIO_setConfig(CONFIG_GPIO_LED_0, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>
              GPIO_setConfig(CONFIG_GPIO_LED_1, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>
          <br>
              GPIO_setConfig(CONFIG_GPIO_BUTTON_0, GPIO_CFG_IN_PU | GPIO_CFG_IN_INT_FALLING);<br>
              GPIO_setConfig(CONFIG_GPIO_BUTTON_1, GPIO_CFG_IN_PU | GPIO_CFG_IN_INT_FALLING);<br>
          <br>
              /* Turn on user LED */<br>
              GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_ON);<br>
              GPIO_write(CONFIG_GPIO_LED_1, CONFIG_GPIO_LED_ON);<br>
          <br>
              /* Install Button callback */<br>
              GPIO_setCallback(CONFIG_GPIO_BUTTON_0, gpioButtonFxn0);<br>
              GPIO_setCallback(CONFIG_GPIO_BUTTON_1, gpioButtonFxn1);<br>
          <br>
              /* Enable interrupts */<br>
              GPIO_enableInt(CONFIG_GPIO_BUTTON_0);<br>
              GPIO_enableInt(CONFIG_GPIO_BUTTON_1);<br>
          <br>
              // initialize room-temp to current temperature read by device.<br>
              // initialize set point to the room temperature<br>
              roomTemp = readTemp();<br>
              setPoint = roomTemp;<br>
              uint32_t serverDisplayTicks = 10000000; //1sec is 10000000 us<br>
              uint16_t totalTime = 0;<br>
          <br>
              // output board data to command prompt<br>
              DISPLAY( snprintf(output, 150, "<Room Temperature: %02d, Set Temperature: %02d, Activation Status(0-OFF, 1-ON): %d, Mode(0-OFF, 1-HEATING, 2-COOLING): %d, Total Time Since Execution: %04d>\n\r",<br>
                                roomTemp, setPoint, activationStatus, systemMode, totalTime));<br>
          <br>
              while(1){<br>
          <br>
                  // Each case represents a 100 millisecond period of activation, up to 1 second inwhich the period condition value will reset it's value back to 0, or the initial period index<br>
                  switch(periodCondition){<br>
          <br>
                      case 0:                                                                     // every 200 ms update the heating/cooling LED and activation status to ON/OFF<br>
          <br>
                          buttonStatusCh();                                                       // if both buttons have been activated then cycle to the next system mode option<br>
                          checkTempStatus();                                                      // compare set point temperature to the room temperature reading and activate/deactivate the system appropriately<br>
          <br>
                          buttonReset();                                                          // reset both button 0 and 1 activation status to off, 0.<br>
                          break;<br>
          <br>
                      case 1:<br>
                          break;<br>
          <br>
                      case 2:                                                                    // every 200 ms update the heating/cooling LED and activation status to ON/OFF<br>
          <br>
                          buttonStatusCh();                                                      // if both buttons have been activated then cycle to the next system mode option<br>
                          checkTempStatus();                                                     // compare set point temperature to the room temperature reading and activate/deactivate the system appropriately<br>
          <br>
                          buttonReset();                                                          // reset both button 0 and 1 activation status to off, 0.<br>
                          break;<br>
          <br>
                      case 3:<br>
                          break;<br>
          <br>
                      case 4:                                                                     // every 200 ms update the heating/cooling LED and activation status to ON/OFF<br>
                          roomTemp = readTemp();                                                  // every 500 ms update temperature sensor reading in roomTemp variable<br>
          <br>
                          buttonStatusCh();                                                       // if both buttons have been activated then cycle to the next system mode option<br>
                          checkTempStatus();                                                      // compare set point temperature to the room temperature reading and activate/deactivate the system appropriately<br>
          <br>
                          buttonReset();                                                          // reset both button 0 and 1 activation status to off, 0.<br>
                          break;<br>
          <br>
                      case 5:                                                                     // every 500 ms update roomTemp to current room temperature measurement<br>
                          if(!(roomTemp > -1 && roomTemp < 120)){                                 // if room temperature reading is out-of-bounds set room-temp to 0<br>
                              //error code                                                        // and turn off heatStatus/LED<br>
                              DISPLAY( snprintf(output, 150, "error reading room temperature(temp. sensor fault)"));<br>
                              roomTemp = 0;<br>
                              GPIO_write(CONFIG_GPIO_LED_0, CONFIG_GPIO_LED_OFF);<br>
                              activationStatus = 0;<br>
                              systemMode = 0;<br>
                          }<br>
                          break;<br>
          <br>
                      case 6:                                                                     // every 200 ms update the heating/cooling LED and activation status to ON/OFF<br>
          <br>
                          buttonStatusCh();                                                       // if both buttons have been activated then cycle to the next system mode option<br>
                          checkTempStatus();                                                      // compare set point temperature to the room temperature reading and activate/deactivate the system appropriately<br>
          <br>
                          buttonReset();                                                          // reset both button 0 and 1 activation status to off, 0.<br>
                          break;<br>
          <br>
                      case 7:<br>
                          break;<br>
          <br>
                      case 8:                                                                     // every 200 ms update the heating/cooling LED and activation status to ON/OFF<br>
          <br>
                          buttonStatusCh();                                                       // if both buttons have been activated then cycle to the next system mode option<br>
                          checkTempStatus();                                                      // compare set point temperature to the room temperature reading and activate/deactivate the system appropriately<br>
          <br>
                          buttonReset();                                                          // reset both button 0 and 1 activation status to off, 0.<br>
                          break;<br>
          <br>
                      case 9:                                                                    // every 1 sec update server with thermostats current data<br>
                          roomTemp = readTemp();                                                  // every 500ms update temperature sensor reading stored in roomTemp variable<br>
          <br>
                          totalTime = Timer_getCount(timer0) / serverDisplayTicks;                // output board data to command prompt<br>
                          DISPLAY( snprintf(output, 150, "<Room Temperature: %02d, Set Temperature: %02d, Mode(0-OFF, 1-HEATING, 2-COOLING): %d, Total Time Since Execution: %04d>\n\r",<br>
                                           roomTemp, setPoint, systemMode, totalTime));<br>
                          break;<br>
          <br>
                      default:<br>
                          break;<br>
          <br>
                  }<br>
          <br>
          <br>
          <br>
              }<br>
          <br>
              return;<br>
          }<br>         
          </p>      
    </div>                   
    </div>

   
  </div>
  
</body>
</html>
